# Пример использования `sync.Cond` в Go для синхронизации горутин, ожидающих определенного условия
### Пример кода

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	// Создаем мьютекс и условие
	var mutex sync.Mutex
	cond := sync.NewCond(&mutex)

	// Переменная состояния
	ready := false

	// WaitGroup для синхронизации завершения горутин
	var wg sync.WaitGroup

	// Запускаем 3 горутины-ожидателя
	for i := 1; i <= 3; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()

			mutex.Lock()
			// Ожидаем, пока ready не станет true
			for !ready {
				fmt.Printf("Горутина %d: ожидает\n", id)
				cond.Wait() // Блокируется до сигнала
			}
			fmt.Printf("Горутина %d: условие выполнено, продолжаю\n", id)
			mutex.Unlock()
		}(i)
	}

	// Даем ожидающим горутинам время на запуск
	time.Sleep(100 * time.Millisecond)

	// Отправляем сигнал всем ожидающим горутинам
	fmt.Println("Основная горутина: отправляю сигнал")
	mutex.Lock()
	ready = true
	cond.Broadcast() // Разблокирует все ожидающие горутины
	mutex.Unlock()

	// Ждем завершения всех горутин
	wg.Wait()
	fmt.Println("Все горутины завершили работу")
}
```

### Объяснение

1. **Создание `sync.Cond`**:
    - `sync.Cond` используется для координации горутин, ожидающих определенного условия.
    - Создается с помощью `sync.NewCond(&mutex)`, где `mutex` — это `sync.Mutex`, обеспечивающий защиту общей переменной состояния (`ready`).

2. **Переменная состояния**:
    - `ready` — булева переменная, которая указывает, выполнено ли условие. Изначально `false`.

3. **Ожидающие горутины**:
    - Запускаются 3 горутины, каждая из которых:
        - Захватывает мьютекс (`mutex.Lock()`).
        - Проверяет условие (`ready`) в цикле `for !ready`.
        - Если условие не выполнено, вызывает `cond.Wait()`, который:
            - Разблокирует мьютекс.
            - Приостанавливает горутину до получения сигнала.
            - После сигнала автоматически захватывает мьютекс снова.
        - После выполнения условия выводит сообщение и освобождает мьютекс.

4. **Сигнал от основной горутины**:
    - Основная горутина ждет 100 мс, чтобы дать ожидающим горутинам запуститься.
    - Затем захватывает мьютекс, устанавливает `ready = true` и вызывает `cond.Broadcast()`.
    - `Broadcast()` отправляет сигнал всем ожидающим горутинам, разблокируя их.

5. **Синхронизация завершения**:
    - `sync.WaitGroup` используется для ожидания завершения всех горутин перед завершением программы.

### Ожидаемый вывод

```
Горутина 1: ожидает
Горутина 2: ожидает
Горутина 3: ожидает
Основная горутина: отправляю сигнал
Горутина 1: условие выполнено, продолжаю
Горутина 2: условие выполнено, продолжаю
Горутина 3: условие выполнено, продолжаю
Все горутины завершили работу
```

**Примечание**: Порядок вывода сообщений от горутин может варьироваться из-за конкурентного выполнения. Однако все горутины дождутся сигнала перед продолжением, и финальное сообщение появится только после их завершения.

### Рекомендации по использованию `sync.Cond`

1. **Используйте цикл для проверки условия**:
    - Всегда проверяйте условие в цикле (`for !ready`), так как `cond.Wait()` может быть разбужен spuriously (ложное пробуждение) или другими сигналами, не связанными с вашим условием.

2. **Выбирайте между `Signal` и `Broadcast`**:
    - `cond.Signal()` будит только одну ожидающую горутину, что полезно, если только одна должна продолжить.
    - `cond.Broadcast()` будит все ожидающие горутины, как в примере, когда все должны продолжить.

3. **Управляйте мьютексом корректно**:
    - Вызывайте `mutex.Lock()` перед `cond.Wait()` и `mutex.Unlock()` после завершения работы с общей переменной.
    - `cond.Wait()` автоматически разблокирует и заблокирует мьютекс, поэтому не вызывайте `Unlock` внутри цикла ожидания.

4. **Избегайте блокировки**:
    - Убедитесь, что мьютекс не удерживается дольше, чем необходимо, чтобы избежать блокировки других горутин.

5. **Когда использовать `sync.Cond`**:
    - Используйте `sync.Cond` для сложных сценариев, где горутины должны ждать выполнения условия (например, очередь задач, пул потоков).
    - Для простых сценариев синхронизации (например, ожидание завершения) рассмотрите `sync.WaitGroup` или каналы.

6. **Альтернативы**:
    - Если логика синхронизации простая, каналы (`chan`) могут быть более идиоматичным решением в Go.
    - Для одноразовых событий рассмотрите использование `sync.Once` или каналов с буфером 1.

7. **Отладка**:
    - Логируйте действия (как в примере) для понимания порядка выполнения.
    - Используйте инструменты вроде `go vet` или `race detector` (`go run -race`) для выявления проблем конкурентности.

### Когда `sync.Cond` полезен
`sync.Cond` идеально подходит для сценариев, где:
- Множество горутин ждут события или состояния (например, данные в очереди).
- Условие сложное и не сводится к простому завершению задачи.
- Требуется эффективное ожидание без активного опроса (polling).

Этот пример демонстрирует базовое использование `sync.Cond`. Для более сложных случаев (например, ограниченная очередь) можно добавить дополнительные проверки и условия.

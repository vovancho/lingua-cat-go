# Пример использования `sync.Mutex` в Go для синхронизации доступа к общей переменной в конкурентной среде

```go
package main

import (
   "fmt"
   "sync"
)

func main() {
   // Общая переменная - счетчик
   var counter int

   // Создаем мьютекс для защиты counter
   var mutex sync.Mutex

   // WaitGroup для синхронизации завершения горутин
   var wg sync.WaitGroup

   // Запускаем 5 горутин, каждая увеличивает счетчик 1000 раз
   for i := 1; i <= 5; i++ {
      wg.Add(1)
      go func(id int) {
         defer wg.Done()
         for j := 0; j < 1000; j++ {
            // Захватываем мьютекс перед доступом к counter
            mutex.Lock()
            counter++
            // Освобождаем мьютекс после обновления
            mutex.Unlock()
         }
         fmt.Printf("Горутина %d: завершила работу\n", id)
      }(i)
   }

   // Ждем завершения всех горутин
   wg.Wait()

   // Выводим финальное значение счетчика
   fmt.Printf("Финальное значение счетчика: %d\n", counter)
}
```

### Объяснение

1. **Создание `sync.Mutex`**:
   - `sync.Mutex` используется для обеспечения взаимоисключающего доступа к общей переменной (`counter`).
   - Переменная `mutex` типа `sync.Mutex` создается для защиты `counter` от одновременного доступа.

2. **Общая переменная**:
   - `counter` — целочисленная переменная, которая будет увеличиваться конкурентными горутинами.
   - Без мьютекса одновременные записи в `counter` приведут к состоянию гонки (race condition).

3. **Горутины**:
   - Запускаются 5 горутин, каждая из которых:
      - Выполняет 1000 инкрементов `counter`.
      - Перед каждым инкрементом вызывает `mutex.Lock()` для захвата мьютекса.
      - После инкремента вызывает `mutex.Unlock()` для освобождения мьютекса.
   - Это гарантирует, что только одна горутина может изменять `counter` в любой момент времени.

4. **Синхронизация завершения**:
   - `sync.WaitGroup` используется для ожидания завершения всех горутин перед выводом финального значения `counter`.

5. **Почему мьютекс важен**:
   - Без `sync.Mutex` операция `counter++` неатомарна (состоит из чтения, инкремента и записи), что может привести к потере обновлений или некорректным значениям.
   - Мьютекс сериализует доступ, устраняя состояние гонки.

### Ожидаемый вывод

```
Горутина 1: завершила работу
Горутина 2: завершила работу
Горутина 3: завершила работу
Горутина 4: завершила работу
Горутина 5: завершила работу
Финальное значение счетчика: 5000
```

**Примечание**:
- Порядок сообщений от горутин может варьироваться из-за конкурентного выполнения.
- Финальное значение счетчика всегда будет 5000 (5 горутин × 1000 инкрементов), так как мьютекс предотвращает состояние гонки.

### Рекомендации по использованию `sync.Mutex`

1. **Минимизируйте область блокировки**:
   - Захватывайте мьютекс только на время, необходимое для доступа к общей переменной.
   - В примере `mutex.Lock()` и `mutex.Unlock()` окружают только `counter++`, а не весь цикл.

2. **Избегайте длительных операций под мьютексом**:
   - Не выполняйте длительные вычисления или операции ввода-вывода, удерживая мьютекс, чтобы не блокировать другие горутины.

3. **Проверяйте на состояние гонки**:
   - Используйте флаг `-race` при запуске программы (`go run -race main.go`), чтобы выявить потенциальные состояния гонки.

4. **Используйте `defer` для `Unlock` (при необходимости)**:
   - Если внутри критической секции возможны паники или сложная логика, используйте `defer mutex.Unlock()` сразу после `mutex.Lock()`, чтобы гарантировать освобождение мьютекса.

5. **Рассмотрите `sync.RWMutex` для чтения**:
   - Если общая переменная часто читается и редко изменяется, используйте `sync.RWMutex`, который позволяет множественным читателям работать одновременно.

6. **Альтернативы мьютексу**:
   - Для простых операций, таких как инкремент счетчика, рассмотрите пакет `sync/atomic` (например, `atomic.AddInt32`).
   - Для координации горутин каналы (`chan`) могут быть более идиоматичным решением в Go.
   - Для одноразовой инициализации используйте `sync.Once`.

7. **Избегайте повторного захвата**:
   - `sync.Mutex` не является рекурсивным. Попытка вызвать `Lock()` на уже захваченном мьютексе в той же горутине приведет к взаимоблокировке (deadlock).

8. **Документируйте мьютексы**:
   - Если мьютекс используется в структуре, добавьте комментарии, указывающие, какие поля он защищает.

9. **Когда использовать `sync.Mutex`**:
   - Используйте `sync.Mutex`, когда нужно защитить общую переменную или ресурс от одновременного доступа.
   - Примеры: счетчики, мапы, списки, доступ к файлам или сетевым ресурсам.

### Когда `sync.Mutex` полезен
`sync.Mutex` идеально подходит для:
- Защиты общей переменной или структуры данных от конкурентного доступа.
- Простых сценариев, где требуется взаимоисключение.
- Ситуаций, где каналы или атомарные операции избыточны или не подходят.

Этот пример демонстрирует базовое использование `sync.Mutex` для защиты счетчика. Для более сложных случаев (например, защита мапы или сложной структуры) мьютекс можно комбинировать с другими примитивами синхронизации, такими как `sync.Cond` или каналы.

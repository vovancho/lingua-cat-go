# Пример использования `sync.RWMutex` в Go для синхронизации доступа к общей переменной, с поддержкой разделения чтения и записи

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	// Общая переменная - счетчик
	var counter int

	// Создаем RWMutex для защиты counter
	var rwMutex sync.RWMutex

	// WaitGroup для синхронизации завершения горутин
	var wg sync.WaitGroup

	// Запускаем 3 горутины-читателя
	for i := 1; i <= 3; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			for j := 0; j < 5; j++ {
				// Захватываем мьютекс для чтения
				rwMutex.RLock()
				fmt.Printf("Читатель %d: текущее значение счетчика = %d\n", id, counter)
				rwMutex.RUnlock()
				time.Sleep(50 * time.Millisecond) // Имитация работы
			}
		}(i)
	}

	// Запускаем 2 горутины-писателя
	for i := 1; i <= 2; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			for j := 0; j < 3; j++ {
				// Захватываем мьютекс для записи
				rwMutex.Lock()
				counter++
				fmt.Printf("Писатель %d: увеличил счетчик до %d\n", id, counter)
				rwMutex.Unlock()
				time.Sleep(100 * time.Millisecond) // Имитация работы
			}
		}(i)
	}

	// Ждем завершения всех горутин
	wg.Wait()

	// Выводим финальное значение счетчика
	fmt.Printf("Финальное значение счетчика: %d\n", counter)
}
```

### Объяснение

1. **Создание `sync.RWMutex`**:
   - `sync.RWMutex` — это мьютекс с разделением доступа на чтение и запись.
   - Позволяет множественным горутинам одновременно читать данные (`RLock`), но только одной горутине писать (`Lock`).
   - Переменная `rwMutex` типа `sync.RWMutex` защищает `counter`.

2. **Общая переменная**:
   - `counter` — целочисленная переменная, которую читатели читают, а писатели увеличивают.
   - Без `RWMutex` одновременный доступ приведет к состоянию гонки.

3. **Горутины-читатели**:
   - Запускаются 3 горутины-читателя, каждая:
      - Выполняет 5 итераций чтения `counter`.
      - Использует `rwMutex.RLock()` для захвата мьютекса в режиме чтения.
      - Читает и выводит значение `counter`, затем вызывает `rwMutex.RUnlock()`.
      - Множественные читатели могут работать одновременно.

4. **Горутины-писатели**:
   - Запускаются 2 горутины-писателя, каждая:
      - Выполняет 3 итерации инкремента `counter`.
      - Использует `rwMutex.Lock()` для захвата мьютекса в режиме записи.
      - Увеличивает `counter` и выводит результат, затем вызывает `rwMutex.Unlock()`.
      - Писатель блокирует всех читателей и других писателей.

5. **Синхронизация завершения**:
   - `sync.WaitGroup` ожидает завершения всех горутин перед выводом финального значения `counter`.

6. **Почему `sync.RWMutex` полезен**:
   - В отличие от `sync.Mutex`, который полностью блокирует доступ, `RWMutex` позволяет параллельное чтение, что повышает производительность в сценариях с частым чтением и редкой записью.
   - Гарантирует отсутствие состояния гонки для `counter`.

### Ожидаемый вывод

```
Читатель 1: текущее значение счетчика = 0
Читатель 2: текущее значение счетчика = 0
Читатель 3: текущее значение счетчика = 0
Писатель 1: увеличил счетчик до 1
Читатель 1: текущее значение счетчика = 1
Читатель 2: текущее значение счетчика = 1
Читатель 3: текущее значение счетчика = 1
Писатель 2: увеличил счетчик до 2
...
Писатель 1: увеличил счетчик до 5
Писатель 2: увеличил счетчик до 6
Читатель 1: текущее значение счетчика = 6
Читатель 2: текущее значение счетчика = 6
Читатель 3: текущее значение счетчика = 6
Финальное значение счетчика: 6
```

**Примечание**:
- Порядок сообщений может варьироваться из-за конкурентности.
- Читатели могут выводить значения одновременно, так как `RLock` допускает параллельное чтение.
- Финальное значение счетчика будет 6 (2 писателя × 3 инкремента).

### Рекомендации по использованию `sync.RWMutex`

1. **Используйте для сценариев с частым чтением**:
   - `sync.RWMutex` наиболее эффективен, когда чтение происходит значительно чаще, чем запись, так как позволяет параллельное чтение.

2. **Минимизируйте область блокировки**:
   - Захватывайте `RLock` или `Lock` только на время, необходимое для доступа к данным.
   - В примере `RLock`/`Lock` окружают только операции с `counter`.

3. **Избегайте длительных операций под мьютексом**:
   - Не выполняйте длительные вычисления или I/O, удерживая `RLock` или `Lock`, чтобы не блокировать других горутин.

4. **Проверяйте на состояние гонки**:
   - Используйте `go run -race main.go` для выявления проблем конкурентности.

5. **Используйте `defer` для разблокировки (при необходимости)**:
   - Если критическая секция сложная, используйте `defer rwMutex.RUnlock()` или `defer rwMutex.Unlock()` после захвата мьютекса.

6. **Когда использовать `sync.RWMutex` вместо `sync.Mutex`**:
   - Если операции чтения преобладают, `RWMutex` повышает производительность за счет параллельного чтения.
   - Если чтение и запись сбалансированы или запись преобладает, используйте `sync.Mutex`, чтобы избежать накладных расходов `RWMutex`.

7. **Избегайте повторного захвата**:
   - Как и `sync.Mutex`, `RWMutex` не рекурсивен. Повторный вызов `Lock` или `RLock` в той же горутине может вызвать взаимоблокировку.

8. **Альтернативы**:
   - Для простых операций (например, инкремент счетчика) рассмотрите `sync/atomic`.
   - Для сложной синхронизации используйте каналы или `sync.Cond`.
   - Для кэширования данных с редкими обновлениями рассмотрите `sync.Map`.

9. **Документируйте использование**:
   - Указывайте в комментариях, какие данные защищает `RWMutex` и какие методы используют `RLock` или `Lock`.

10. **Тестируйте производительность**:
   - Сравните производительность `RWMutex` и `Mutex` в вашем сценарии, так как `RWMutex` имеет дополнительные накладные расходы.

### Когда `sync.RWMutex` полезен
`sync.RWMutex` идеально подходит для:
- Сценариев с частым чтением и редкой записью (например, кэши, конфигурации, словари).
- Защиты структур данных, где параллельное чтение безопасно, но запись требует исключительного доступа.
- Приложений, где производительность чтения критична.

Этот пример демонстрирует базовое использование `sync.RWMutex` для защиты счетчика. Для более сложных случаев (например, кэш с обновлением по таймеру) можно комбинировать `RWMutex` с другими примитивами синхронизации, такими как каналы или `sync.Cond`.